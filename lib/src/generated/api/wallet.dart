// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.28.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'descriptor.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// Rust type: RustOpaqueNom<Mutex < lwk_wollet :: Wollet >>
@sealed
class MutexLwkWolletWollet extends RustOpaque {
  MutexLwkWolletWollet.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  MutexLwkWolletWollet.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: LwkCore
        .instance.api.rust_arc_increment_strong_count_MutexLwkWolletWollet,
    rustArcDecrementStrongCount: LwkCore
        .instance.api.rust_arc_decrement_strong_count_MutexLwkWolletWollet,
    rustArcDecrementStrongCountPtr: LwkCore
        .instance.api.rust_arc_decrement_strong_count_MutexLwkWolletWolletPtr,
  );
}

class Wallet {
  final MutexLwkWolletWollet ptr;

  const Wallet.raw({
    required this.ptr,
  });

  Future<Address> address({required int index, dynamic hint}) =>
      LwkCore.instance.api.walletAddress(
        that: this,
        index: index,
      );

  Future<Address> addressLastUnused({dynamic hint}) =>
      LwkCore.instance.api.walletAddressLastUnused(
        that: this,
      );

  Future<List<Balance>> balances({dynamic hint}) =>
      LwkCore.instance.api.walletBalances(
        that: this,
      );

  Future<String> blindingKey({dynamic hint}) =>
      LwkCore.instance.api.walletBlindingKey(
        that: this,
      );

  static Future<String> broadcastTx(
          {required String electrumUrl,
          required List<int> txBytes,
          dynamic hint}) =>
      LwkCore.instance.api.walletBroadcastTx(
          electrumUrl: electrumUrl, txBytes: txBytes, hint: hint);

  Future<String> buildAssetTx(
          {required int sats,
          required String outAddress,
          required double absFee,
          required String asset,
          dynamic hint}) =>
      LwkCore.instance.api.walletBuildAssetTx(
        that: this,
        sats: sats,
        outAddress: outAddress,
        absFee: absFee,
        asset: asset,
      );

  Future<String> buildLbtcTx(
          {required int sats,
          required String outAddress,
          required double absFee,
          dynamic hint}) =>
      LwkCore.instance.api.walletBuildLbtcTx(
        that: this,
        sats: sats,
        outAddress: outAddress,
        absFee: absFee,
      );

  Future<PsetAmounts> decodeTx({required String pset, dynamic hint}) =>
      LwkCore.instance.api.walletDecodeTx(
        that: this,
        pset: pset,
      );

  Future<String> descriptor({dynamic hint}) =>
      LwkCore.instance.api.walletDescriptor(
        that: this,
      );

  factory Wallet(
          {required Network network,
          required String dbpath,
          required DescriptorBase descriptor,
          dynamic hint}) =>
      LwkCore.instance.api.walletNew(
          network: network, dbpath: dbpath, descriptor: descriptor, hint: hint);

  Future<Uint8List> signTx(
          {required Network network,
          required String pset,
          required String mnemonic,
          dynamic hint}) =>
      LwkCore.instance.api.walletSignTx(
        that: this,
        network: network,
        pset: pset,
        mnemonic: mnemonic,
      );

  Future<void> sync({required String electrumUrl, dynamic hint}) =>
      LwkCore.instance.api.walletSync(
        that: this,
        electrumUrl: electrumUrl,
      );

  Future<List<Tx>> txs({dynamic hint}) => LwkCore.instance.api.walletTxs(
        that: this,
      );

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Wallet && runtimeType == other.runtimeType && ptr == other.ptr;
}
